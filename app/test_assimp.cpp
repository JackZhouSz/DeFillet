//
// Created by xiaowuga on 2024/10/24.
//
#include <easy3d/core/surface_mesh.h>

#include <easy3d/fileio/surface_mesh_io.h>
#include <easy3d/util/file_system.h>

#include <3rd_party/fastobj/fast_obj.h>
#include <easy3d/core/surface_mesh_builder.h>
#include <easy3d/renderer/texture_manager.h>
#include <easy3d/algo/tessellator.h>

#include <easy3d/renderer/renderer.h>
#include <easy3d/util/file_system.h>
#include <easy3d/renderer/drawable_triangles.h>
#include <easy3d/viewer/viewer.h>

namespace easy3d {
    namespace internal {

        // each group is a set of faces (denoted by their indices) sharing the same material
        struct Group : public std::vector<SurfaceMesh::Face> {
            vec3 ambient;
            vec3 diffuse;
            vec3 specular;
            float shininess;
            std::string tex_file;
        };
    }
}

void save_obj_file_with_mtl(const std::string &file_name, easy3d::SurfaceMesh* mesh) {
    auto htc = mesh->halfedge_property<easy3d::vec2>("h:texcoord");
    std::string mtl_path = easy3d::file_system::name_less_all_extensions(file_name) + ".mtl";
    std::string simple_name = easy3d::file_system::simple_name(mtl_path);
    std::ofstream objFile(file_name);
    if (!objFile.is_open()) {
        std::cerr << "Failed to open OBJ file for writing." << std::endl;
        return;
    }
    objFile << "# OBJ file generated by fucking" << std::endl;
    objFile << "mtllib " << simple_name << std::endl;
    for(auto v : mesh->vertices()) {
        easy3d::vec3 p = mesh->position(v);
        objFile << "v " << p.x << " " << p.y << " " << p.z << std::endl;
    }
    if(htc) {
        auto vtc = mesh->vertex_property<easy3d::vec2>("v:texcoord");
        for(auto h : mesh->halfedges()) {
            if(mesh->face(h).is_valid())
                vtc[mesh->source(h)] = htc[h];
        }
        for(auto v : mesh->vertices()) {
            easy3d::vec2 tex_coord = vtc[v];
            objFile << "vt " << tex_coord.x << " " << tex_coord.y << std::endl;
        }
    }
    for (auto f :  mesh->faces()) {
        objFile << "f ";
        for (auto v : mesh->vertices(f)) {
            objFile << v.idx() + 1;  // OBJ indices start from 1
            if (htc) {
                objFile << "/" << v.idx() + 1; // Append texture coordinate index
            }
            objFile << " ";
        }
        objFile << std::endl;
    }


    std::ofstream mtlFile(mtl_path);
    if (!mtlFile.is_open()) {
        std::cerr << "Failed to open MTL file for writing." << std::endl;
        return;
    }

    auto tex_file = mesh->model_property<std::string>("m:tex_file");
    if(tex_file) {
        std::string tmp = easy3d::file_system::simple_name(tex_file[0]);
        mtlFile << "newmtl material" << std::endl;
        mtlFile << "map_Kd " << tmp << std::endl;
    }
    objFile.close();
    mtlFile.close();

    std::cout << "OBJ file with MTL created successfully." << std::endl;
}

easy3d::Model *load_obj_file_with_mtl(const std::string &file_name, easy3d::Viewer* viewer) {
    if (!easy3d::file_system::is_file(file_name)) {
        LOG(ERROR) << "file does not exist: " << file_name;
        return nullptr;
    }

    if (easy3d::file_system::extension(file_name, true) != "obj")
        return nullptr;

    fastObjMesh *fom = fast_obj_read(file_name.c_str());
    if (!fom) {
        LOG(ERROR) << "failed reading file: " + file_name;
        return nullptr;
    }

    // Attention: Valid indices in the fastObjMesh::indices array start from 1.
    // A dummy position, normal and texture coordinate are added to the corresponding fastObjMesh arrays at
    // element 0 and then an index of 0 is used to indicate that attribute is not present at the vertex.

    // ------------------------ build the mesh ------------------------

    // clear the mesh in case of existing data
    easy3d::SurfaceMesh *mesh = new easy3d::SurfaceMesh;
    mesh->set_name(file_name);

    easy3d::SurfaceMeshBuilder builder(mesh);
    builder.begin_surface();

    // add vertices
    // skip the first point
    for (std::size_t v = 1; v < fom->position_count; ++v) {
        // Should I create vertices later, to get rid of isolated vertices?
        builder.add_vertex(easy3d::vec3(fom->positions + v * 3));
    }

    // create texture coordinate property if texture coordinates present
    easy3d::SurfaceMesh::HalfedgeProperty<easy3d::vec2> prop_texcoords;
    if (fom->texcoord_count > 0 && fom->texcoords) // index starts from 1 and the first element is dummy
        prop_texcoords = mesh->add_halfedge_property<easy3d::vec2>("h:texcoord");

    // create face color property if material information exists
    easy3d::SurfaceMesh::FaceProperty<easy3d::vec3> prop_face_color;
    if (fom->material_count > 0 && fom->materials)  // index starts from 1 and the first element is dummy
        prop_face_color = mesh->add_face_property<easy3d::vec3>("f:color");

    // find the face's halfedge that points to v.
    auto find_face_halfedge = [](easy3d::SurfaceMesh *mesh, easy3d::SurfaceMesh::Face face,
                                 easy3d::SurfaceMesh::Vertex v) -> easy3d::SurfaceMesh::Halfedge {
        for (auto h : mesh->halfedges(face)) {
            if (mesh->target(h) == v)
                return h;
        }
        LOG_N_TIMES(3, ERROR) << "could not find a halfedge pointing to " << v << " in face " << face
                              << ". " << COUNTER;
        return easy3d::SurfaceMesh::Halfedge();
    };

    // group the faces according to the material
    // each group is a set of faces sharing the same material
    std::vector<easy3d::internal::Group> groups(fom->material_count);
    std::set<std::string> tex_file_set;
    // for each shape
    for (std::size_t ii = 0; ii < fom->group_count; ii++) {
        const fastObjGroup &grp = fom->groups[ii];

//                if (grp.name)
//                    std::cout << "group name: " << std::string(grp.name) << std::endl;

        unsigned int idx = 0;


        for (unsigned int jj = 0; jj < grp.face_count; ++jj) {
            // number of vertices in the face
            unsigned int fv = fom->face_vertices[grp.face_offset + jj];
            std::vector<easy3d::SurfaceMesh::Vertex> vertices;
            std::vector<unsigned int> texcoord_ids;
            for (unsigned int kk = 0; kk < fv; ++kk) {  // for each vertex in the face
                const fastObjIndex &mi = fom->indices[grp.index_offset + idx];
                if (mi.p)
                    vertices.emplace_back(easy3d::SurfaceMesh::Vertex(mi.p - 1));
                if (mi.t)
                    texcoord_ids.emplace_back(mi.t);
                ++idx;
            }

            easy3d::SurfaceMesh::Face face = builder.add_face(vertices);
            if (face.is_valid()) {
                // texture coordinates
                if (prop_texcoords && texcoord_ids.size() == vertices.size()) {
                    auto begin = find_face_halfedge(mesh, face, builder.face_vertices()[0]);
                    auto cur = begin;
                    unsigned int vid = 0;
                    do {
                        unsigned int tid = texcoord_ids[vid++];
                        prop_texcoords[cur] = easy3d::vec2(fom->texcoords + 2 * tid);
                        cur = mesh->next(cur);
                    } while (cur != begin);
                }

                // now materials
                if (prop_face_color) {
                    unsigned int mat_id = fom->face_materials[grp.face_offset + jj];
                    const fastObjMaterial &mat = fom->materials[mat_id];
                    prop_face_color[face] = easy3d::vec3(mat.Kd); // currently easy3d uses only diffuse
                }

                auto get_file_name = [](const char *name, const char* path) -> std::string {
                    std::string file_name("");
                    if (name && easy3d::file_system::is_file(std::string(name)))
                        file_name = std::string(name);
                    else if (path && easy3d::file_system::is_file(std::string(path)))
                        file_name = std::string(path);
                    else if (name && path){
                        const std::string test_name = std::string(path) + "/" + std::string(name);
                        if (easy3d::file_system::is_file(test_name))
                            file_name = test_name;
                    }
                    return file_name;
                };

                if (fom->material_count > 0 && fom->materials) {
                    unsigned int mat_id = fom->face_materials[grp.face_offset + jj];
                    const fastObjMaterial &mat = fom->materials[mat_id];
                    auto &g = groups[mat_id];
                    g.push_back(face);
                    g.ambient = easy3d::vec3(mat.Ka);
                    g.diffuse = easy3d::vec3(mat.Kd);
                    g.specular = easy3d::vec3(mat.Ks);
                    g.shininess = mat.Ns;
                    g.tex_file = get_file_name(mat.map_Ka.name, mat.map_Ka.path); // use ambient texture it exists
                    if (g.tex_file.empty())
                        g.tex_file = get_file_name(mat.map_Kd.name, mat.map_Kd.path); // then try diffuse texture
                    if (g.tex_file.empty())
                        g.tex_file = get_file_name(mat.map_Ks.name, mat.map_Ks.path); // then try diffuse texture
                    if(!g.tex_file.empty())
                        tex_file_set.insert(g.tex_file);
                }
            }
        }
    }
    builder.end_surface();
    if(tex_file_set.size() == 1) {
        auto tex_file = mesh->model_property<std::string>("m:tex_file");
        tex_file[0] = *tex_file_set.begin();
    }
    // since the mesh has been built, skip texture if material and texcoord information don't exist
    if ((fom->material_count > 0 && fom->materials) == false) {
        return mesh;
    }

    if ((fom->material_count > 0 && fom->materials) == false) {
        viewer->add_model(mesh, true);
        return mesh;
    }
    else
        viewer->add_model(mesh, false);


    mesh->update_vertex_normals();
    auto normals = mesh->get_vertex_property<easy3d::vec3>("v:normal");
    auto points = mesh->get_vertex_property<easy3d::vec3>("v:point");

    easy3d::Tessellator tessellator;
    for (std::size_t i = 0; i < groups.size(); ++i) {
        const auto &group = groups[i];
        if (group.empty())
            continue;

        tessellator.reset();

        for (auto face : group) {
            tessellator.begin_polygon(mesh->compute_face_normal(face));
            tessellator.set_winding_rule(easy3d::Tessellator::WINDING_NONZERO);  // or POSITIVE
            tessellator.begin_contour();
            for (auto h : mesh->halfedges(face)) {
                auto v = mesh->target(h);
                easy3d::Tessellator::Vertex vtx(points[v], v.idx());
                vtx.append(normals[v]);
                if (prop_texcoords)
                    vtx.append(prop_texcoords[h]);
                if (prop_face_color)
                    vtx.append(prop_face_color[face]);
                tessellator.add_vertex(vtx);
            }
            tessellator.end_contour();
            tessellator.end_polygon();
        }

        std::vector<easy3d::vec3> d_points, d_colors, d_normals;
        std::vector<easy3d::vec2> d_texcoords;
        const std::vector<easy3d::Tessellator::Vertex*>& vts = tessellator.vertices();
        for (auto v :vts) {
            std::size_t offset = 0;
            d_points.emplace_back(v->data() + offset);
            offset += 3;
            d_normals.emplace_back(v->data() + offset);
            offset += 3;
            if (prop_texcoords) {
                d_texcoords.emplace_back(v->data() + offset);
                offset += 2;
            }
            if (prop_face_color)
                d_colors.emplace_back(v->data() + offset);
        }

        const auto &d_indices = tessellator.elements();

        auto drawable = mesh->renderer()->add_triangles_drawable("faces_" + std::to_string(i));

        drawable->update_element_buffer(d_indices);
        drawable->update_vertex_buffer(d_points);
        drawable->update_normal_buffer(d_normals);
        if (!d_colors.empty())
            drawable->update_color_buffer(d_colors);
        if (!d_texcoords.empty())
            drawable->update_texcoord_buffer(d_texcoords);

        drawable->set_smooth_shading(false);
        if (prop_texcoords) {
            if (!group.tex_file.empty()) {
                easy3d::Texture *tex = easy3d::TextureManager::request(group.tex_file, easy3d::Texture::REPEAT);
                if (tex) {
                    drawable->set_texture_coloring(easy3d::State::HALFEDGE, "h:texcoord", tex);
                    drawable->set_distinct_back_color(false);
                    LOG(INFO) << "texture created from " << group.tex_file;
                }
            }
        }

        if (!drawable->texture()) { // in case texture creation failed
            if (prop_face_color)
                drawable->set_property_coloring(easy3d::State::Location::FACE, "f:color");
            else
                drawable->set_uniform_coloring(easy3d::vec4(group.diffuse, 1.0f));
        }
    }

    return mesh;
}


int main() {

    // easy3d::SurfaceMesh* mesh = new easy3d::SurfaceMesh;
    // auto v1 = mesh->add_vertex(easy3d::vec3(0.0, 0.0, 0.0));
    // auto v2 = mesh->add_vertex(easy3d::vec3(1.0, 0.0, 0.0));
    // auto v3 = mesh->add_vertex(easy3d::vec3(1.0, 1.0, 0.0));
    // auto v4 = mesh->add_vertex(easy3d::vec3(0.0, 1.0, 0.0));
    // mesh->add_quad(v1,v2, v3, v4);
    // auto texture_coordinate = mesh->vertex_property<easy3d::vec2>("v:texture_coordinate");
    // texture_coordinate[v1] = easy3d::vec2(0,0);
    // texture_coordinate[v2] = easy3d::vec2(1,0);
    // texture_coordinate[v3] = easy3d::vec2(1,1);
    // texture_coordinate[v4] = easy3d::vec2(0,1);
    // std::string obj_path = "../output.obj";
    // std::vector<std::string> texture_files = {"1.png"};
    // save_mesh_to_obj_with_mtl(mesh, obj_path, texture_files);
    easy3d::Viewer viewer("asd");
    easy3d::SurfaceMesh* mesh = dynamic_cast<easy3d::SurfaceMesh*>(load_obj_file_with_mtl("../output1.obj", &viewer));
    save_obj_file_with_mtl("../output.obj", mesh);
    viewer.run();
    return 0;
}